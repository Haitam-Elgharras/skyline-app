generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "mysql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model users {
  id             Int       @id @default(autoincrement())
  name           String    @db.VarChar(255)
  email          String    @unique @db.VarChar(255)
  image          String    @db.VarChar(255)
  phone          String?   @db.VarChar(255)
  // password       String    @db.VarChar(255)
  type           String    @db.VarChar(255)
  // houseId        String?   @db.VarChar(255) //POSSIBLE TO BE EMTPY
  accountStatus  String    @db.VarChar(255)
  email_Verified Boolean
  create_time    DateTime? @db.DateTime()
  update_time    DateTime? @db.DateTime()
}

model tenants {
  id            Int       @id @default(autoincrement())
  name          String    @db.VarChar(255)
  email         String?   @db.VarChar(255)
  phone         String?   @db.VarChar(255)
  image         String?   @db.VarChar(255)
  familySize    Int?
  isMarried     Boolean?
  profession    String?   @db.VarChar(255)
  buildingId    String?   @db.VarChar(255)
  houseId       String?   @db.VarChar(255)
  cin           String?   @db.VarChar(255)
  cinRecto      String?   @db.VarChar(255)
  cinVerso      String?   @db.VarChar(255)
  accountStatus String    @db.VarChar(255)
  notes         String?   @db.VarChar(65535)
  create_time   DateTime? @db.DateTime()
  update_time   DateTime? @db.DateTime()
}

model buildings {
  id              Int       @id @default(autoincrement())
  name            String    @unique @db.VarChar(255)
  location        String    @db.VarChar(255)
  thumbnail       String    @db.VarChar(255)
  floors          Int
  images          String?   @db.VarChar(255) //POSSIBLE TO BE MULTIPLE PHOTOS
  houseQuantity   Int
  populationTotal Int?
  houseIDs        String?   @db.VarChar(255) //THIS STRING IS A 2 DIMENSIONAL ARRAY, WITH EACH ARRAY IN THE FIRST DIMENSION, REPRESENTING A FLOOR AND CONTAINING houseIDs FOR THE HOUSES IN THAT SPECIFIC FLOOT
  surface         Float
  userIDs         String?   @db.VarChar(255) //POSSIBLE TO BE EMTPY
  notes           String?   @db.VarChar(65535) //THE 65535 length is equivalent to the length of the data type "TEXT"
  create_time     DateTime? @db.DateTime()
  update_time     DateTime? @db.DateTime()

}

model houses {
  id                    Int       @id @default(autoincrement())
  name                  String    @db.VarChar(255)
  description           String?   @db.VarChar(1000)
  buildingId            Int
  thumbnail             String    @db.VarChar(255)
  images                String?   @db.VarChar(255) //POSSIBLE TO BE EMTPY
  bedrooms              Int?
  bathrooms             Int?
  saloon                Int?
  kitchen               Int?
  userIDs               String?   @db.VarChar(255) //POSSIBLE TO BE EMTPY
  location              String    @db.VarChar(255) //GET THIS FROM BUILDING LOCATION
  size                  Float
  percentangeOfBuilding Int
  status                String    @db.VarChar(255)
  // buyOrRent          String?
  priceBuy              Float
  // pricePerMeter         Float
  // priceRent          Float?
  comment               String?   @db.VarChar(65535) //THE 65535 length is equivalent to the length of the data type "TEXT"
  expenseIDs            String?   @db.VarChar(255) //POSSIBLE TO BE EMTPY
  create_time           DateTime? @db.DateTime()
  update_time           DateTime? @db.DateTime()

}

model sales {
  id             Int       @id @default(autoincrement())
  houseId        Int
  houseName      String    @db.VarChar(255)
  buildingId     String    @db.VarChar(255)
  buildingName   String    @db.VarChar(255)
  comment        String?   @db.VarChar(65535) //THE "65535" length is equivalent to the length of the data type "TEXT"
  userIDs        String
  buyMonths      Int //POSSIBLE TO BE "1", MEANING THE FULL PAYEMENT IS PROVIDED INSTANTLY
  remainingPrice Float?
  payementIDs    String?   @db.VarChar(255)
  create_time    DateTime? @db.DateTime()
  update_time    DateTime? @db.DateTime()

}

model payements {
  id          Int       @id @default(autoincrement())
  type        String    @db.VarChar(255)
  userID      Int
  comment     String?   @db.VarChar(65535) //THE 65535 length is equivalent to the length of the data type "TEXT"
  amount      Float
  month       Int
  status      String?   @db.VarChar(255)
  houseId     Int
  buildingId  String    @db.VarChar(255)
  create_time DateTime? @db.DateTime()
  update_time DateTime? @db.DateTime()
}

model expenses {
  id          Int       @id @default(autoincrement())
  reason      String    @db.VarChar(255)
  comment     String?   @db.VarChar(65535) //THE 65535 length is equivalent to the length of the data type "TEXT"
  amount      Float
  date        DateTime?
  status      String?   @db.VarChar(255)
  buildingId  Int? //THIS FIELD IS NULLABLE BECAUSE IT COULD BE A EXPENSE FOR THE HOUSE, OR FOR THE WHOLE BUILDING
  houseId     Int? //THIS FIELD IS NULLABLE BECAUSE IT COULD BE A GENERAL EXPENSE FOR THE BUILDING, OR FOR A SPECIFIC HOUSE
  create_time DateTime? @db.DateTime()
  update_time DateTime? @db.DateTime()
}

//BELLOW ARE THE MODELS NEEDED BY NextAuth.js

// model Account {
//   id                String  @id @default(cuid())
//   userId            String
//   type              String
//   provider          String
//   providerAccountId String
//   refresh_token     String? @db.Text
//   access_token      String? @db.Text
//   expires_at        Int?
//   token_type        String?
//   scope             String?
//   id_token          String? @db.Text
//   session_state     String?

//   user User @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@unique([provider, providerAccountId])
// }

// model Session {
//   id           String   @id @default(cuid())
//   sessionToken String   @unique
//   userId       String
//   expires      DateTime
//   user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
// }

// model User {
//   id            String    @id @default(cuid())
//   name          String?
//   email         String?   @unique
//   emailVerified DateTime?
//   image         String?
//   accounts      Account[]
//   sessions      Session[]
// }

// model VerificationToken {
//   identifier String
//   token      String   @unique
//   expires    DateTime

//   @@unique([identifier, token])
// }
